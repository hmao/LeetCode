### 类的加载时机
1. 当虚拟机启动时，初始化用户指定的主类，就是启动执行的 main 方法所在的类;
2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类，就是 new 一个类的时候要初始化;
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类;
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类;
5. 子类的初始化会触发父类的初始化;
6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化， 会触发该接口的初始化;
7. 使用反射 API 对某个类进行反射调用时，初始化这个类，其实跟前面一样，反射调用 要么是已经有实例了，要么是静态方法，都需要初始化;
8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的 类。



### 不会初始化

1. 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
2. 定义对象数组，不会触发该类的初始化。
3. 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不 会触发定义常量所在的类。
4. 通过类名获取 Class 对象，不会触发类的初始化，Hello.class 不会让 Hello 类初始 化。
5. 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触 发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。Class.forName (“jvm.Hello”)默认会加载 Hello 类。
6. 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作(加载了，但是 不初始化)。


### 三类加载器

1. 启动类加载器(BootstrapClassLoader) 
    负责加载JRE的核心类库，如jre目标下的rt.jar,charsets.jar等
2. 扩展类加载器(ExtClassLoader)
    负责加载JRE扩展目录ext中JAR类包
3. 应用类加载器(AppClassLoader)
    负责加载ClassPath路径下的类包




### 加载器特点
1. 双亲委托 
ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用
这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常

 因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。
 
 优点  
1. 可以保证java核心类库的安全，即保证由引导类加载器加载的类不能被用户随便替换，用户不能自己随便定义一个二进制名也为
java.lang.String 的类来替换java核心类库的java.lang.String类，否则会抛出ClassCastException。


2. 使得一个类的不同版本可以共存在jvm中，带来了极大的灵活性，OSGi技术的实现就是得益于此。

缺点：  

 而根据一个类的定义加载器是这个类中引用的其它类的初始加载器可知，java核心类库中定义的类是不能使用系统类加载器定义的类。而java提供了很多服务提供者接口（Service Provider Interface SPI),许可第三方来实现这些类的接口。第三方开发的类通常是由应用类加载器在类路径下（classpath）来找到并且定义的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给系统类加载器，因为它是系统类加载器的祖先类加载器。也就是说，类加载器的双亲委托模型无法解决这个问题，这是双亲委托模型的缺点。



2. 负责依赖 


3. 缓存加载


### JVM 命令行工具
1. jps/jinfo 查看 java 进程
  jps/jps -lmv
2. jstat 查看 JVM 内部 gc 相关信息   
   stat -gc 1763 1000 100 
   每隔1000 ms，1000次  
   stat -gcutil 1763 1000 1000（使用率）  
3. jmap 查看 heap 或类占用空间统计 
  jmap -histo 1763   
  jmap -heap 1763  
4. jstack 查看线程信息  
  jstack -l 1763  
5. jcmd 执行 JVM 相关分析命令(整合命令)  
  jcmd pid VM.version  
  jcmd pid VM.flags  
  jcmd pid VM.command_line  
  jcmd pid VM.system_properties   
  jcmd pid Thread.print  
  jcmd pid GC.class_histogram  
  jcmd pid GC.heap_info     
6. jrunscript/jjs 执行 js 命令  
  当curl命令用:   
  jrunscript -e "cat('http://www.baidu.com')" 执行js脚本片段  
  jrunscript -e "print('hello,kk.jvm'+1)" 执行js文件  
  jrunscript -l js -f /XXX/XXX/test.js  
7. JVM 图形化工具--jconsole  
   JVM 图形化工具--jvisualvm  
   JVM 图形化工具--jmc  
   
### JVM
Eden so s1 8:1:1  
由如下参数控制提升阈值 -XX:+MaxTenuringThreshold=15  
mark-and-sweep algorithm.  
   The algorithm traverses all object references, starting with the GC roots, and marks every object found as alive.    
   All of the heap memory that is not occupied by marked objects is reclaimed. It is simply marked as free, essentially swept free of unused objects.  
可以作为 GC Roots 的对象  
1. 当前正在执行的方法里的局部变量和输入参数  
2. 活动线程(Active threads)  
3. 所有类的静态字段(static field) 
4. JNI 引用

停止-复制(mark-copy)  
标记-清除(Mark-Sweep)  
标记-整理(Mark-Compact)  
分代收集算法(Generational Collection)  
效率：复制算法>标记/整理算法>标记/清除算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此  
内存整齐度：复制算法=标记/整理算法>标记/清除算法。  
内存利用率：标记/整理算法=标记/清除算法>复制算法。 

1. Parallel GC  
-XX:+UseParallelGC
2. Mostly Concurrent Mark and Sweep Garbage Collector  
-XX:+UseConcMarkSweepGC
3. G1 GC

### NIO
端口：进程  
ip：计算机  

## 阻塞式 IO

一般通过在 while(true) 循环中服务 端会调用 accept() 方法等待接收客户 端的连接的方式监听请求，请求一旦 接收到一个连接请求，就可以建立通 信套接字在这个通信套接字上进行读 写操作，此时不能再接收其他客户端 连接请求，只能等待同当前连接的客 户端的操作执行完成， 不过可以通过 多线程来支持多个客户端的连接

 Runnable#run()没有返回值   
 Callable#call()方法有返回值  
 
 创建固定线程池的经验  
 
 1. 如果是CPU密集型，则线程池大小设置成N或N+1  
 2. 如果是IO密集型，则线程池大小设置为2N或2N+2  
 
 ### Spring AOP
 
AOP-面向切面编程  
Spring 早期版本的核心功能，管理对象生命周期与对象装配  
为了实现管理和装配，一个自然而然的想法就是，加一个中间层代理(字节码增强)来实现所有对象 的托管  
IoC-控制反转  
也称为 DI(Dependency Injection)依赖注入  
对象装配思路的改进  
从对象 A 直接引用和操作对象 B，变成对象 A 里指需要依赖一个接口 IB，系统启动和装配阶段，把 IB 接口的实例对象注入到对象 A，这样 A 就不需要依赖一个 IB 接口的具体实现，也就是类 B  
从而可以实现在不修改代码的情况，修改配置文件，即可以运行时替换成注入 IB 接口另一实现类 C 的一个对象实例  


实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；  
二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。  


### Sprig IOC

若要理解Spring IoC的优点，首先要理解控制反转的思想。控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统（IOC容器），将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中  

控制是否被反转其实正是框架和库（Framework and Library）的区别  

客户程序员使用库，框架使用客户程序员  

对于一个库而言，用户程序员使用的方式是主动调用它，这是通常情况的做法，也就是“正向”控制；而对于一个框架，往往将用户程序员编写的代码注册到框架中，最后由框架来调用用户程序员编写的代码，这就构成了控制反转。也就是说，控制反转的关键在于“控制者”是谁。对于一个库而言，复用的可能只是算法和数据结构；而对于一个框架而言，复用的往往还有控制流逻辑，这也是控制反转的结果  

通过以上的描述，可以看到似乎有点回调的感觉了  

ioc的思想最核心的地方在于，资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处：  

- 第一，资源集中管理，实现资源的可配置和易管理  

- 第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度  

也就是说，甲方要达成某种目的不需要直接依赖乙方，它只需要将想要达到的目的告诉第三方机构就可以了。比如甲方需要一双袜子，而乙方它卖一双袜子，它要把袜子卖出去，并不需要自己去直接找到一个买家来完成袜子的卖出。它也只需要找第三方，告诉别人我要卖一双袜子。这下好了，甲乙双方进行交易活动，都不需要自己直接去找卖家与买家，相当于程序内部开放接口，卖家由第三方作为参数传入。甲乙互相不依赖，而且只有在进行交易活动的时候，甲才和乙产生联系。反之亦然。这样做什么好处么呢，甲乙可以在对方不真实存在的情况下独立存在，而且保证不交易时候无联系，想交易的时候可以很容易的产生联系。甲乙交易活动不需要双方见面，避免了双方的互不信任造成交易失败的问题。因为交易由第三方来负责联系，而且甲乙都认为第三方可靠。那么交易就能很可靠很灵活的产生和进行了。这就是ioc的核心思想。在实际生活中常见的第三方支付平台和电子商务平台就是这样的道理。利用庞大的ioc容器，交易双方之外的第三方，提供可靠性可依赖可灵活变更交易方的资源管理中心。另外人事代理也是雇佣机构和个人之外的第三方  

在以上的描述中，笔者从中为大家提炼了两个专业词汇：依赖注入和控制反转。所谓的依赖注入是甲方开放接口，在它需要的时候，能够将乙方传递进来(注入)；所谓的控制反转，甲乙双方不相互依赖，交易活动的进行不依赖于甲乙任何一方，整个活动的进行由第三方负责管理。这就是spring IoC的思想所在  

## Class 文件级加载
Java 源代码 --> java 编译器 --> .class文件(二进制文件) -> JVM 虚拟机读取字节码文件，取出二进制数据，加载到内存中  
https://blog.csdn.net/zhangjg_blog/article/details/21486985
class文件是一种8位字节的二进制流文件， 各个数据项按顺序紧密的从前向后排列， 相邻的项之间没有间隙， 这样可以使得class文件非常紧凑， 体积轻巧， 可以被JVM快速的加载至内存， 并且占据较少的内存空间。 我们的Java源文件， 在被编译之后， 每个类（或者接口）都单独占据一个class文件， 并且类中的所有信息都会在class文件中有相应的描述， 由于class文件很灵活， 它甚至比Java源文件有着更强的描述能力。

class文件中的信息是一项一项排列的， 每项数据都有它的固定长度， 有的占一个字节， 有的占两个字节， 还有的占四个字节或8个字节， 数据项的不同长度分别用u1, u2, u4, u8表示， 分别表示一种数据项在class文件中占据一个字节， 两个字节， 4个字节和8个字节。 可以把u1, u2, u3, u4看做class文件数据项的“类型” 。

### 反射

简单的来说，反射机制指的是程序在运行时能够获取自身的信息。在java中，只要给定类的名字，
那么就可以通过反射机制来获得类的所有信息。

反射的意义及优缺点  

1.增加程序的灵活性，避免将程序写死到代码里。

2.代码简洁，提高代码的复用率，外部调用方便

3.对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法

反射的缺点
性能问题  

1.使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此Java反射机制主要应用在对灵活性和扩展性要求很高的系统框架上,普通程序不建议使用。

2.反射包括了一些动态类型，所以JVM无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被 执行的代码或对性能要求很高的程序中使用反射。

使用反射会模糊程序内部逻辑  

程序人员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术，因而会带来维护问题。反射代码比相应的直接代码更复杂。

安全限制  

使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如Applet，那么这就是个问题了

内部暴露  

由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用－－代码有功能上的错误，降低可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化

### java中byte、 int、char、long、float、double各占多少字节数？

类型	字符数  
byte	1字节  
char	2字节  
short	2字节  
int	4字节  
float	4字节  
long	8字节  
double	8字节  
boolean	至少1字节  

### Spring事务传播机制
PROPAGATION_REQUIRED —— 支持当前事务，如果当前没有事务，则新建一个事务，这是最常见的选择，也是 Spring 默认的一个事务传播属性  

PROPAGATION_SUPPORTS —— 支持当前事务，如果当前没有事务，则以非事务方式执行  

PROPAGATION_MANDATORY —— 支持当前事务，如果当前没有事务，则抛出异常  

PROPAGATION_REQUIRES_NEW —— 新建事务，如果当前存在事务，把当前事务挂起  

PROPAGATION_NOT_SUPPORTED —— 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起  

PROPAGATION_NEVER —— 以非事务方式执行，如果当前存在事务，则抛出异常  

PROPAGATION_NESTED —— Nested的事务和它的父事务是相依的，它的提交是要等和它的父事务一块提交的  

### Spring事务的四种隔离级别

1、ISOLATION_DEFAULT  

这是一个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别  

以下4个与 JDBC 的隔离级别相对应  

2、ISOLATION_READ_UNCOMMITTED  

这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据  
这种隔离级别会产生脏读，不可重复读和幻读  

3、 ISOLATION_READ_COMMITTED  

保证一个事务修改的数据提交后才能被另外一个事务读取，其它事务不能读取该事务未提交的数据  
这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读  

4、ISOLATION_REPEATABLE_READ  

保证一个事务不能读取另一个事务未提交的数据，避免了“脏读取”和“不可重复读取”的情况，但是带来了更多的性能损失  

这种事务隔离级别可以防止脏读，不可重复读，但是可能出现幻读  

5、ISOLATION_SERIALIZABLE  

这是最可靠的但是代价花费最高的事务隔离级别，事务被处理为顺序执行  
除了可防止脏读，不可重复读外，还避免了幻读  


### List 和 Set区别

两个接口都是继承自Collection​，是常用来存放数据项的集合，主要区别如下：

① List和Set之间很重要的一个区别是是否允许重复元素的存在，在List中允许插入重复的元素，而在Set中不允许重复元素存在  

② 与元素先后存放顺序有关，List是有序集合，会保留元素插入时的顺序，Set是无序集合  

③ List可以通过下标来访问，而Set不能  

### Java ArrayList底层实现原理

概述  
    会自动扩容的数组，线程不安全  
    查询快，增删慢   
底层实现
    Object数组实现，存入元素时会丢失类型  
    底层扩容因子为原长度的1.5倍  
    默认数组长度是10，扩容时最大长度为int最大数  
    对象内部有继承自父类AbstractList的modcount属性  
    每次对数组结构进行改变时，该值都会增加1  
    在迭代器中会有expectedModCount值，会与此值进行比较，如果一致迭代；不一致，抛出异常  
    简单校验，防止迭代期间原始集合改变  
RandomAccess接口
    用于标明实现该接口的List支持快速随机访问，主要目的是使算法能够在随机和顺序访问的list中表现的更加高效。  
    所以有此接口的集合，优先选用for循环遍历;  
方法
    继承自list的对元素和索引的增删改查   
    removeRange(int start,int end):范围内删除，开始到结束-1  
    trimToSize()：缩小长度  
    
  ArrayList是List接口的可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小  
   每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量  
   注意，此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步  
### Linux命令用过哪些

https://blog.csdn.net/ljianhui/article/details/11100625

系统  

 uname -a               # 查看内核/操作系统/CPU信息  
lsb_release -a         # 查看操作系统版本 (适用于所有的linux，包括Redhat、SuSE、Debian等发行版，但是在debian下要安装lsb)     
cat /proc/cpuinfo      # 查看CPU信息  
 hostname               # 查看计算机名  
 lspci -tv              # 列出所有PCI设备  
 lsusb -tv              # 列出所有USB设备  
 lsmod                  # 列出加载的内核模块  
 env                    # 查看环境变量  
资源  

 free -m                # 查看内存使用量和交换区使用量  
 df -h                  # 查看各分区使用情况  
 du -sh <目录名>        # 查看指定目录的大小  
 grep MemTotal /proc/meminfo   # 查看内存总量  
 grep MemFree /proc/meminfo    # 查看空闲内存量  
 uptime                 # 查看系统运行时间、用户数、负载  
 cat /proc/loadavg      # 查看系统负载  
磁盘和分区  

 mount | column -t      # 查看挂接的分区状态  
 fdisk -l               # 查看所有分区   
 swapon -s              # 查看所有交换分区  
 hdparm -i /dev/hda     # 查看磁盘参数(仅适用于IDE设备)  
 dmesg | grep IDE       # 查看启动时IDE设备检测状况  
网络  

 ifconfig               # 查看所有网络接口的属性  
 iptables -L            # 查看防火墙设置  
 route -n               # 查看路由表  
netstat -lntp          # 查看所有监听端口  
 netstat -antp          # 查看所有已经建立的连接  
 netstat -s             # 查看网络统计信息  
进程

 ps -ef                 # 查看所有进程  
 top                    # 实时显示进程状态  
 
### B+树索引和哈希索引的区别

B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接  

在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高  

因此，B+树索引被广泛应用于数据库、文件系统等场景。顺便说一下，xfs文件系统比ext3/ext4效率高很多的原因之一就是，它的文件及目录索引结构全部采用B+树索引，而ext3/ext4的文件目录结构则采用Linked list, hashed B-tree、Extents/Bitmap等索引数据结构，因此在高I/O压力下，其IOPS能力不如xfs  

简单地说，哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。

从上面的图来看，B+树索引和哈希索引的明显区别是：

如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据  

从示意图中也能看到，如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索  

同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询  

哈希索引也不支持多列联合索引的最左匹配规则  

B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题  

### 解决哈希冲突的常用方法分析

1 开放定址法  
从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。  
在开放定址法中解决冲突的方法有：线行探查法、平方探查法、双散列函数探查法。  
开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素  

2 再哈希法
就是同时构造多个不同的哈希函数：  
Hi = RHi(key) i= 1,2,3 ... k;   
当H1 = RH1(key) 发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时  

3. 链地址法  
链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况  
如下一组数字,(32、40、36、53、16、46、71、27、42、24、49、64)哈希表长度为13，哈希函数为H(key)=key%13,则链表法结果如下  
0         
1  -> 40 -> 27 -> 53   
2  
3  -> 16 -> 42  
4  
5  
6  -> 32 -> 71  
7  -> 46  
8  
9  
10 -> 36 -> 49  
11 -> 24  
12 -> 64  
注：在java中，链接地址法也是HashMap解决哈希冲突的方法之一，jdk1.7完全采用单链表来存储同义词，jdk1.8则采用了一种混合模式，对于链表长度大于8的，会转换为红黑树存储
