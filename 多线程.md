### 什么是线程
线程(Thread)就是程序代码执行的一条线, 在Java代码层面看来, 是一个方法调用另一个方法，依次排列 的方法调用链。
当然，线程是操作系统中的概念，被称为轻量级的进程，是分配CPU资源和调度执行的基本单位。

### 什么是进程?
进程(Process)是操作系统中的概念，是应用程序的一次动态执行过程，操作系统会给他分配各种资源， 比如内存，文件，以及CPU资源。
每个进程都有自己的内存空间，相对于静态的应用程序二进制代码来说，这个虚拟内存地址空间就是一 个副本。
比如，我们用命令行启动一次Java程序，就说启动了一个JVM进程。

### 线程与进程有什么区别?

一般来说，进程中可以包含多个线程，这些线程共享一块内存地址空间。
在Linux系统中，线程和进程概念并没有严格区分。
粗略来看，它们的区别有:
线程被称为轻量级的进程，线程之间的切换开销更小，线程占用的资源比进程少。 进程之间是独立的，不能共享内存地址空间;【Linux的轻量级进程我们当做线程来看即可】

### Java中怎么创建线程?

Java语言中创建线程本质上只有一种方式: new Thread() 。 启动线程则是调用 start() 方法。
Java中，继承 Thread 类，实现 Runnable 接口，实现 Callable 接口，这些方式创建的都是可执行任 务，并没有真正地创建线程。

### thread#start() 和 thread#run() 方法有什么区别?
thread#start():启动一个新线程并异步执行其中的认为（真正创建了一个物理线程）
thread#run():在当前线程执行，和调用其他对象的普通方法没有什么区别

### runnable 与 callable接口有什么区别
 runnable#run() 没有返回值
 callable#call() 方法有返回值
 
### thread 类与runnable接口有什么关系
 Thread类继承了Runnable接口，创建线程对象时，可以传入需要执行的 Runnable 任务。


### 线程有哪些状态
Thread的状态包括:
1. NEW:初始状态, 尚未启动
2. RUNNABLE: 可运行状态
3. RUNNING: 运行中
4. READY: 就绪状态
5. WAITING: 等待状态
6. TIMED_WAITING: 限时等待被唤醒的状态 BLOCKED: 阻塞状态,被对象锁或者IO阻塞 TERMINATED: 终止状态

###  什么是守护线程?与前台线程的区别在哪里?

守护线程(Daemon Thread)也叫后台线程。
在JVM中，如果没有正在运行中的前台线程，则JVM就会自动结束运行，而不管守护线程。 所以守护线 程一般用于执行某些可以被放弃的任务或事件

 Thread thread = new Thread(task);
 thread.setName("test-thread-1");
 thread.setDaemon(false);
 
### thread.sleep(0)与TimeUnit.milliseconds.sleep(0)有什么不同
 
 TimeUnit.MILLISECONDS.sleep(0) 没有效果，因为数值 0 会被过滤掉。
 首先来看源码，原来是对Thread.sleep方法的包装，实现是一样的，只是多了时间单位转换和验证，然而TimeUnit枚举成员的方法却提供更好的可读性
 
    public void sleep(long timeout) throws InterruptedException {
        if (timeout > 0) {
            long ms = toMillis(timeout);
            int ns = excessNanos(timeout, ms);
            Thread.sleep(ms, ns);
        }
    }
    
    
 两种方法都可以实现线程休眠，让出CPU资源。
Thread.sleep(0L) 的用处是先让出CPU资源，然后再让操作系统进行调度，和 Thread.yield() 类
似。
TimeUnit.MILLISECONDS.sleep() 方法是对 Thread.sleep() 的快捷封装。

### 并行和并发在你看来有什么区别

concurrent: 并发，指多个线程在共同完成一件事情; 互相之间有依赖/有状态，例如多个部门做同 一个系统。
parallel: 并行，指多个线程各做各的事情; 互相之间无共享状态，例如两个公司，各做各的项目。
在GC算法中: concurrent指GC线程和业务线程一起执行的阶段; parallel则是指多个GC线程之间的并 行执行。

### 为什么需要多线程?

多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务。
本质原因是摩尔定律失效，CPU进入多核时代。加上互联网时代的来临，分布式系统开发大规模普及。

### 多线程有什么优势?

多线程编程方式，通过合理的分工，能充分利用多个CPU核心，提高程序的执行性能。 再比如一个餐馆，多个服务员之间可以看做是多个并行线程。服务员和厨师之间则可以看多是多个并发
线程。

### 多线程有什么不好的地方

1. 多线程的程序更加复杂，开发成本更高;
2. 消耗更多的资源，比如内存，CPU等等;
3. 多线程需要协调和管理，会相互影响，有资源竞争问题。

### 如何让一个线程执行完再执行第二个?

1. 使用 Thread#join() 方法，可以让当前线程阻塞, 等待指定的 thread 执行完成后，再执行当前 线程。
2. 当前线程wait，直到指定线程执行完时执行notify通知唤醒当前线程执行。
3. Lock和Condition也可以达到类似效果。
4. Semaphore/CountDownLatch/CyclicBarrier都可以实现。

### 怎样让两个线程以指定顺序交替执行?

可以使用细粒度的锁(fine-grained locks)来控制执行顺序。
比如使用Java内置的 object.wait() 和 object.notify() 方法，依次执行完并通知对方。 或者使用同一个锁的多个 Condition, 分别等待。
或者创建自定义线程时, 使用 CountDownLatch 和 CyclicBarrier 等工具进行辅助。


### thread.sleep 和 object#wait 的区别

thread.sleep 当前线程阻塞，让出CPU  
Object#wait() : 当前线程进入等待状态，释放持有的锁
### 线程之间如何通信?

### 线程间通信(inter-thread communication)主要有两种方式:
1. 共享内存: 多个线程之间使用堆内存之中的对象/属性作为状态值,来进行隐式的通信。
2. 信号传递: 线程之间通过明确的发送信号来进行显式的通信

###  什么是线程安全

线程安全是多线程环境下的一个概念，保证多个线程并发执行同一段代码时，不会出现不确定的结果， 也不会出现与单线程执行时不一致的结果。 也就是保证多个线程对共享状态操作的正确性。
在Java中，完全由代码来控制线程安全，共享状态一般是指堆内存中的数据(对象的属性)。


### 线程安全有哪些特征?

原子性: 对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要 么执行，要么不执行。两个原子性的操作，先后执行，不能保证整体原子性。
可见性: 一个线程执行的修改操作，对其他线程来说必须立即可见。 Java 提供了volatile 关键字来 保证可见性，读取时强制从主内存读取。可见性不能解决原子性。
有序性: 保证线程内的串行语义，避免指令重排，例如增加内存屏障。

### CountDownLatch和CyclicBarrier 区别
都有让多个线程等待同步然后再开始下一步动作的意。
但是CountDownLatch的下一步的动作实施者是主线程，具有不可重复性；而CyclicBarrier的下一步动作实施者还是“其他线程”本身，具有往复多次实施动作的特点。

### 类加载和初始化的过程是线程安全的吗? 哪些情况下是不安全的?

类加载的过程是同步阻塞方式的，所以是线程安全的。
类和对象初始化的过程也是同步阻塞的，但如果初始化代码中有引用泄漏，则可能造成其他问题。

### ThreadLocal 是什么


### 线程池的作用

在实际开发中，线程都是用线程池进行管理的，阿里规范中也是强制要求的。合理使用线程池能带来3个好处：

1. 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
2. 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
3. 提高线程的可管理性。线程是稀缺资源，java线程是绑定在OS上的，是一对一映射关系，创建一个线程要向kernel申请。如果无限制地创建，不仅会消耗系统资源， 还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。

### 线程池实现流程

Executor接口定义了执行任务的execute()，实现流程还要看是哪个线程池实现的，这里用比较典型的ThreadPoolExecutor举例。ThreadPoolExecutor执行execute方法分下面4种情况：

如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤 需要获取全局锁  
如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue  
如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁  
如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用 RejectedExecutionHandler.rejectedExecution()方法  
ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热之后 （当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用基本都是从同步队列里拿，不需要锁，是一个while（true  

### 可重入功能的实现原理

ReentrantLock的实现基于队列同步器（AbstractQueuedSynchronizer，后面简称AQS），关于AQS的实现原理，可以看笔者的另一篇文章：https://juejin.cn/post/6844903842530738184  
Java队列同步器（AQS）到底是怎么一回事  
ReentrantLock的可重入功能基于AQS的同步状态：state  
其原理大致为：当某一线程获取锁后，将state值+1，并记录下当前持有锁的线程，再有线程来获取锁时，判断这个线程与持有锁的线程是否是同一个线程，如果是，将state值再+1，如果不是，阻塞线程  
当线程释放锁时，将state值-1，当state值减为0时，表示当前线程彻底释放了锁，然后将记录当前持有锁的线程的那个字段设置为null，并唤醒其他线程，使其重新竞争锁  


### 为什么当线程池的核心线程满了后，是先加入到阻塞队列，而不是先创建新的线程？

线程池创建线程需要获取mainlock这个全局锁，会影响并发效率，所以使用阻塞队列把第一步创建核心线程与第三步创建最大线程隔离开来，起一个缓冲的作用  
引入阻塞队列，是为了在执行execute()方法时，尽可能的避免获取全局锁 

### 线程池的实现原理是什么
我们通过创建一个线程对象，并且实现Runnable接口就可以实现一个简单的线程。可以利用上多核  
CPU。当一个任务结束，当前线程就接收。 但很多时候，我们不止会执行一个任务。如果每次都是如此的创建线程->执行任务->销毁线程，会造成
很大的性能开销。 那能否一个线程创建后，执行完一个任务后，又去执行另一个任务，而不是销毁。这就是线程池。

这也就是池化技术的思想，通过预先创建好多个线程，放在池中，这样可以在需要使用线程的时候直接 获取，避免多次重复创建、销毁带来的开销。  
如果把线程池比作一个公司。公司会有正式员工处理正常业务，如果工作量大的话，会雇佣外包人员来 工作。  
闲时就可以释放外包人员以减少公司管理开销。一个公司因为成本关系，雇佣的人员始终是有最大数。 如果这时候还有任务处理不过来，就走需求池排任务。  
线程池创建参数如下:  
corePoolSize: 核心线程数量，可以类比正式员工数量，常驻线程数量。    
maximumPoolSize: 最大的线程数量，公司最多雇佣员工数量。常驻+临时线程数量。 workQueue:多余任务等待队列，再多的人都处理不过来了，需要等着，在这个地方等。 keepAliveTime:非核心线程空闲时间，就是外包人员等了多久，如果还没有活干，解雇了。 threadFactory: 创建线程的工厂，在这个地方可以统一处理创建的线程的属性。每个公司对员工 的要求不一样，恩，在这里设置员工的属性。 handler:线程池拒绝策略，什么意思呢?就是当任务实在是太多，人也不够，需求池也排满了， 还有任务咋办?默认是不处理，抛出异常告诉任务提交者，我这忙不过来了。  


### 使用线程池有哪些好处?

避免创建线程的开销。  
避免线程数量爆炸，导致系统崩溃  
合理控制线程数量，避免过度的资源竞争，造成系统性能急剧下降。   
利用特定线程池的功能特征，例如定时调度等  

### 线程池的 submit()和 execute() 方法有什么区别?
submit 方法: 有Future封装的返回值，执行中如果抛出异常，等待的方法中可以 catch 到。  
execute 方法: 无返回值，执行任务是捕捉不到异常的。  

### 线程池有哪些关闭方法?

shutdown() : 停止接收新任务，已有的任务继续执行  
shutdownNow() : 停止接收新任务，停止执行已有的任务，正在执行的线程会抛出 InterruptedException 异常  
awaitTermination(long timeOut, TimeUnit unit) : 当前线程阻塞，等待终止   

### 怎么提交任务?

提交一个任务到线程池中，线程池的处理流程如下:
1、判断线程池里的核心线程是否都在执行任务，如果不是(核心线程空闲或者还有核心线程没有被创 建)则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程  
2、线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。 如果工作队列满了，则进入下个流程  
3、判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果 已经满了，则交给饱和策略来处理这个任务  


### 怎么获取执行结果?

提交task到线程池后，可以获得Futrue对象，然后通过Future.get()获得执行结果。

### 如何控制线程池的线程池容量?

1、如果创建时知道需要多少线程，可以使用 newSingleThreadExecutor 或 newFixedThreadExecutor 创建单线程或固定大小线程  
2、如果不知道，可以使用 创建无限制的线程池。  
3、如果需要控制线程在一定范围内，可以直接使用ThreadPoolExecutor创建  

### 线程池怎样监控?

可以通过jstack，kill -3，jconsole/jvisualvm/jmc等工具监控。


### Java中同步加锁的关键字是什么?

synchronized


### synchronized 的原理是什么?

Java中的每个对象都是对象锁(Object monitor)，主要使用对象头标记字来实现。


### synchronized 方法使用的是哪个对象锁?

实例方法锁的是 this 代表的对象;   
静态方法锁的是对应的 Class 对象;   
synchronized块使用的是 this 对象。   
synchronized(obj)使用的是obj对象。  
