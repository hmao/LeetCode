### 什么是线程
线程(Thread)就是程序代码执行的一条线, 在Java代码层面看来, 是一个方法调用另一个方法，依次排列 的方法调用链。
当然，线程是操作系统中的概念，被称为轻量级的进程，是分配CPU资源和调度执行的基本单位。

### 什么是进程?
进程(Process)是操作系统中的概念，是应用程序的一次动态执行过程，操作系统会给他分配各种资源， 比如内存，文件，以及CPU资源。
每个进程都有自己的内存空间，相对于静态的应用程序二进制代码来说，这个虚拟内存地址空间就是一 个副本。
比如，我们用命令行启动一次Java程序，就说启动了一个JVM进程。

### 线程与进程有什么区别?

一般来说，进程中可以包含多个线程，这些线程共享一块内存地址空间。
在Linux系统中，线程和进程概念并没有严格区分。
粗略来看，它们的区别有:
线程被称为轻量级的进程，线程之间的切换开销更小，线程占用的资源比进程少。 进程之间是独立的，不能共享内存地址空间;【Linux的轻量级进程我们当做线程来看即可】

### Java中怎么创建线程?

Java语言中创建线程本质上只有一种方式: new Thread() 。 启动线程则是调用 start() 方法。
Java中，继承 Thread 类，实现 Runnable 接口，实现 Callable 接口，这些方式创建的都是可执行任 务，并没有真正地创建线程。

### thread#start() 和 thread#run() 方法有什么区别?
thread#start():启动一个新线程并异步执行其中的认为（真正创建了一个物理线程）
thread#run():在当前线程执行，和调用其他对象的普通方法没有什么区别

### runnable 与 callable接口有什么区别
 runnable#run() 没有返回值
 callable#call() 方法有返回值
 
### thread 类与runnable接口有什么关系
 Thread类继承了Runnable接口，创建线程对象时，可以传入需要执行的 Runnable 任务。


### 线程有哪些状态
Thread的状态包括:
1. NEW:初始状态, 尚未启动
2. RUNNABLE: 可运行状态
3. RUNNING: 运行中
4. READY: 就绪状态
5. WAITING: 等待状态
6. TIMED_WAITING: 限时等待被唤醒的状态 BLOCKED: 阻塞状态,被对象锁或者IO阻塞 TERMINATED: 终止状态

###  什么是守护线程?与前台线程的区别在哪里?

守护线程(Daemon Thread)也叫后台线程。
在JVM中，如果没有正在运行中的前台线程，则JVM就会自动结束运行，而不管守护线程。 所以守护线 程一般用于执行某些可以被放弃的任务或事件

 Thread thread = new Thread(task);
 thread.setName("test-thread-1");
 thread.setDaemon(false);
 
### thread.sleep(0)与TimeUnit.milliseconds.sleep(0)有什么不同
 
 TimeUnit.MILLISECONDS.sleep(0) 没有效果，因为数值 0 会被过滤掉。
 首先来看源码，原来是对Thread.sleep方法的包装，实现是一样的，只是多了时间单位转换和验证，然而TimeUnit枚举成员的方法却提供更好的可读性
 
    public void sleep(long timeout) throws InterruptedException {
        if (timeout > 0) {
            long ms = toMillis(timeout);
            int ns = excessNanos(timeout, ms);
            Thread.sleep(ms, ns);
        }
    }
    
    
 两种方法都可以实现线程休眠，让出CPU资源。
Thread.sleep(0L) 的用处是先让出CPU资源，然后再让操作系统进行调度，和 Thread.yield() 类
似。
TimeUnit.MILLISECONDS.sleep() 方法是对 Thread.sleep() 的快捷封装。

### 并行和并发在你看来有什么区别

concurrent: 并发，指多个线程在共同完成一件事情; 互相之间有依赖/有状态，例如多个部门做同 一个系统。
parallel: 并行，指多个线程各做各的事情; 互相之间无共享状态，例如两个公司，各做各的项目。
在GC算法中: concurrent指GC线程和业务线程一起执行的阶段; parallel则是指多个GC线程之间的并 行执行。

### 为什么需要多线程?

多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务。
本质原因是摩尔定律失效，CPU进入多核时代。加上互联网时代的来临，分布式系统开发大规模普及。

### 多线程有什么优势?

多线程编程方式，通过合理的分工，能充分利用多个CPU核心，提高程序的执行性能。 再比如一个餐馆，多个服务员之间可以看做是多个并行线程。服务员和厨师之间则可以看多是多个并发
线程。

### 多线程有什么不好的地方

1. 多线程的程序更加复杂，开发成本更高;
2. 消耗更多的资源，比如内存，CPU等等;
3. 多线程需要协调和管理，会相互影响，有资源竞争问题。

### 如何让一个线程执行完再执行第二个?

1. 使用 Thread#join() 方法，可以让当前线程阻塞, 等待指定的 thread 执行完成后，再执行当前 线程。
2. 当前线程wait，直到指定线程执行完时执行notify通知唤醒当前线程执行。
3. Lock和Condition也可以达到类似效果。
4. Semaphore/CountDownLatch/CyclicBarrier都可以实现。

### 怎样让两个线程以指定顺序交替执行?

可以使用细粒度的锁(fine-grained locks)来控制执行顺序。
比如使用Java内置的 object.wait() 和 object.notify() 方法，依次执行完并通知对方。 或者使用同一个锁的多个 Condition, 分别等待。
或者创建自定义线程时, 使用 CountDownLatch 和 CyclicBarrier 等工具进行辅助。


### thread.sleep 和 object#wait 的区别

thread.sleep 当前线程阻塞，让出CPU  
Object#wait() : 当前线程进入等待状态，释放持有的锁
### 线程之间如何通信?

### 线程间通信(inter-thread communication)主要有两种方式:
1. 共享内存: 多个线程之间使用堆内存之中的对象/属性作为状态值,来进行隐式的通信。
2. 信号传递: 线程之间通过明确的发送信号来进行显式的通信

###  什么是线程安全

线程安全是多线程环境下的一个概念，保证多个线程并发执行同一段代码时，不会出现不确定的结果， 也不会出现与单线程执行时不一致的结果。 也就是保证多个线程对共享状态操作的正确性。
在Java中，完全由代码来控制线程安全，共享状态一般是指堆内存中的数据(对象的属性)。


### 线程安全有哪些特征?

原子性: 对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要 么执行，要么不执行。两个原子性的操作，先后执行，不能保证整体原子性。
可见性: 一个线程执行的修改操作，对其他线程来说必须立即可见。 Java 提供了volatile 关键字来 保证可见性，读取时强制从主内存读取。可见性不能解决原子性。
有序性: 保证线程内的串行语义，避免指令重排，例如增加内存屏障。

### CountDownLatch和CyclicBarrier 区别
都有让多个线程等待同步然后再开始下一步动作的意。
但是CountDownLatch的下一步的动作实施者是主线程，具有不可重复性；而CyclicBarrier的下一步动作实施者还是“其他线程”本身，具有往复多次实施动作的特点。

### 类加载和初始化的过程是线程安全的吗? 哪些情况下是不安全的?

类加载的过程是同步阻塞方式的，所以是线程安全的。
类和对象初始化的过程也是同步阻塞的，但如果初始化代码中有引用泄漏，则可能造成其他问题。

### ThreadLocal 是什么


### 线程池的作用

在实际开发中，线程都是用线程池进行管理的，阿里规范中也是强制要求的。合理使用线程池能带来3个好处：

1. 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
2. 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
3. 提高线程的可管理性。线程是稀缺资源，java线程是绑定在OS上的，是一对一映射关系，创建一个线程要向kernel申请。如果无限制地创建，不仅会消耗系统资源， 还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。

### 线程池实现流程

Executor接口定义了执行任务的execute()，实现流程还要看是哪个线程池实现的，这里用比较典型的ThreadPoolExecutor举例。ThreadPoolExecutor执行execute方法分下面4种情况：

如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤 需要获取全局锁  
如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue  
如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁  
如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用 RejectedExecutionHandler.rejectedExecution()方法  
ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热之后 （当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用基本都是从同步队列里拿，不需要锁，是一个while（true  

### 可重入功能的实现原理

ReentrantLock的实现基于队列同步器（AbstractQueuedSynchronizer，后面简称AQS），关于AQS的实现原理，可以看笔者的另一篇文章：https://juejin.cn/post/6844903842530738184  
Java队列同步器（AQS）到底是怎么一回事  
ReentrantLock的可重入功能基于AQS的同步状态：state  
其原理大致为：当某一线程获取锁后，将state值+1，并记录下当前持有锁的线程，再有线程来获取锁时，判断这个线程与持有锁的线程是否是同一个线程，如果是，将state值再+1，如果不是，阻塞线程  
当线程释放锁时，将state值-1，当state值减为0时，表示当前线程彻底释放了锁，然后将记录当前持有锁的线程的那个字段设置为null，并唤醒其他线程，使其重新竞争锁  


### 为什么当线程池的核心线程满了后，是先加入到阻塞队列，而不是先创建新的线程？

线程池创建线程需要获取mainlock这个全局锁，会影响并发效率，所以使用阻塞队列把第一步创建核心线程与第三步创建最大线程隔离开来，起一个缓冲的作用  
引入阻塞队列，是为了在执行execute()方法时，尽可能的避免获取全局锁 
