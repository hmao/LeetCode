### 什么是线程
线程(Thread)就是程序代码执行的一条线, 在Java代码层面看来, 是一个方法调用另一个方法，依次排列 的方法调用链。
当然，线程是操作系统中的概念，被称为轻量级的进程，是分配CPU资源和调度执行的基本单位。

### 什么是进程?
进程(Process)是操作系统中的概念，是应用程序的一次动态执行过程，操作系统会给他分配各种资源， 比如内存，文件，以及CPU资源。
每个进程都有自己的内存空间，相对于静态的应用程序二进制代码来说，这个虚拟内存地址空间就是一 个副本。
比如，我们用命令行启动一次Java程序，就说启动了一个JVM进程。

### 线程与进程有什么区别?

一般来说，进程中可以包含多个线程，这些线程共享一块内存地址空间。
在Linux系统中，线程和进程概念并没有严格区分。
粗略来看，它们的区别有:
线程被称为轻量级的进程，线程之间的切换开销更小，线程占用的资源比进程少。 进程之间是独立的，不能共享内存地址空间;【Linux的轻量级进程我们当做线程来看即可】

### Java中怎么创建线程?

Java语言中创建线程本质上只有一种方式: new Thread() 。 启动线程则是调用 start() 方法。
Java中，继承 Thread 类，实现 Runnable 接口，实现 Callable 接口，这些方式创建的都是可执行任 务，并没有真正地创建线程。

### thread#start() 和 thread#run() 方法有什么区别?
thread#start():启动一个新线程并异步执行其中的认为（真正创建了一个物理线程）
thread#run():在当前线程执行，和调用其他对象的普通方法没有什么区别

### runnable 与 callable接口有什么区别
 runnable#run() 没有返回值
 callable#call() 方法有返回值
 
### thread 类与runnable接口有什么关系
 Thread类继承了Runnable接口，创建线程对象时，可以传入需要执行的 Runnable 任务。


### 线程有哪些状态
Thread的状态包括:
1. NEW:初始状态, 尚未启动
2. RUNNABLE: 可运行状态
3. RUNNING: 运行中
4. READY: 就绪状态
5. WAITING: 等待状态
6. TIMED_WAITING: 限时等待被唤醒的状态 BLOCKED: 阻塞状态,被对象锁或者IO阻塞 TERMINATED: 终止状态

###  什么是守护线程?与前台线程的区别在哪里?

守护线程(Daemon Thread)也叫后台线程。
在JVM中，如果没有正在运行中的前台线程，则JVM就会自动结束运行，而不管守护线程。 所以守护线 程一般用于执行某些可以被放弃的任务或事件

 Thread thread = new Thread(task);
 thread.setName("test-thread-1");
 thread.setDaemon(false);
 
### thread.sleep(0)与TimeUnit.milliseconds.sleep(0)有什么不同
 
 TimeUnit.MILLISECONDS.sleep(0) 没有效果，因为数值 0 会被过滤掉。
 首先来看源码，原来是对Thread.sleep方法的包装，实现是一样的，只是多了时间单位转换和验证，然而TimeUnit枚举成员的方法却提供更好的可读性
 
    public void sleep(long timeout) throws InterruptedException {
        if (timeout > 0) {
            long ms = toMillis(timeout);
            int ns = excessNanos(timeout, ms);
            Thread.sleep(ms, ns);
        }
    }
    
    
 两种方法都可以实现线程休眠，让出CPU资源。
Thread.sleep(0L) 的用处是先让出CPU资源，然后再让操作系统进行调度，和 Thread.yield() 类
似。
TimeUnit.MILLISECONDS.sleep() 方法是对 Thread.sleep() 的快捷封装。

### 并行和并发在你看来有什么区别

concurrent: 并发，指多个线程在共同完成一件事情; 互相之间有依赖/有状态，例如多个部门做同 一个系统。
parallel: 并行，指多个线程各做各的事情; 互相之间无共享状态，例如两个公司，各做各的项目。
在GC算法中: concurrent指GC线程和业务线程一起执行的阶段; parallel则是指多个GC线程之间的并 行执行。

### 为什么需要多线程?

多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务。
本质原因是摩尔定律失效，CPU进入多核时代。加上互联网时代的来临，分布式系统开发大规模普及。

### 多线程有什么优势?

多线程编程方式，通过合理的分工，能充分利用多个CPU核心，提高程序的执行性能。 再比如一个餐馆，多个服务员之间可以看做是多个并行线程。服务员和厨师之间则可以看多是多个并发
线程。

### 多线程有什么不好的地方

1. 多线程的程序更加复杂，开发成本更高;
2. 消耗更多的资源，比如内存，CPU等等;
3. 多线程需要协调和管理，会相互影响，有资源竞争问题。

### 如何让一个线程执行完再执行第二个?

1. 使用 Thread#join() 方法，可以让当前线程阻塞, 等待指定的 thread 执行完成后，再执行当前 线程。
2. 当前线程wait，直到指定线程执行完时执行notify通知唤醒当前线程执行。
3. Lock和Condition也可以达到类似效果。
4. Semaphore/CountDownLatch/CyclicBarrier都可以实现。

### 怎样让两个线程以指定顺序交替执行?

可以使用细粒度的锁(fine-grained locks)来控制执行顺序。
比如使用Java内置的 object.wait() 和 object.notify() 方法，依次执行完并通知对方。 或者使用同一个锁的多个 Condition, 分别等待。
或者创建自定义线程时, 使用 CountDownLatch 和 CyclicBarrier 等工具进行辅助。


### thread.sleep 和 object#wait 的区别

thread.sleep 当前线程阻塞，让出CPU  
Object#wait() : 当前线程进入等待状态，释放持有的锁
### 线程之间如何通信?

### 线程间通信(inter-thread communication)主要有两种方式:
1. 共享内存: 多个线程之间使用堆内存之中的对象/属性作为状态值,来进行隐式的通信。
2. 信号传递: 线程之间通过明确的发送信号来进行显式的通信

###  什么是线程安全

线程安全是多线程环境下的一个概念，保证多个线程并发执行同一段代码时，不会出现不确定的结果， 也不会出现与单线程执行时不一致的结果。 也就是保证多个线程对共享状态操作的正确性。
在Java中，完全由代码来控制线程安全，共享状态一般是指堆内存中的数据(对象的属性)。


### 线程安全有哪些特征?

原子性: 对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要 么执行，要么不执行。两个原子性的操作，先后执行，不能保证整体原子性。
可见性: 一个线程执行的修改操作，对其他线程来说必须立即可见。 Java 提供了volatile 关键字来 保证可见性，读取时强制从主内存读取。可见性不能解决原子性。
有序性: 保证线程内的串行语义，避免指令重排，例如增加内存屏障。

### CountDownLatch和CyclicBarrier 区别
都有让多个线程等待同步然后再开始下一步动作的意。
但是CountDownLatch的下一步的动作实施者是主线程，具有不可重复性；而CyclicBarrier的下一步动作实施者还是“其他线程”本身，具有往复多次实施动作的特点。

### 类加载和初始化的过程是线程安全的吗? 哪些情况下是不安全的?

类加载的过程是同步阻塞方式的，所以是线程安全的。
类和对象初始化的过程也是同步阻塞的，但如果初始化代码中有引用泄漏，则可能造成其他问题。

### ThreadLocal 是什么


### 线程池的作用

在实际开发中，线程都是用线程池进行管理的，阿里规范中也是强制要求的。合理使用线程池能带来3个好处：

1. 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
2. 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
3. 提高线程的可管理性。线程是稀缺资源，java线程是绑定在OS上的，是一对一映射关系，创建一个线程要向kernel申请。如果无限制地创建，不仅会消耗系统资源， 还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。

### 线程池实现流程

Executor接口定义了执行任务的execute()，实现流程还要看是哪个线程池实现的，这里用比较典型的ThreadPoolExecutor举例。ThreadPoolExecutor执行execute方法分下面4种情况：

如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤 需要获取全局锁  
如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue  
如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁  
如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用 RejectedExecutionHandler.rejectedExecution()方法  
ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热之后 （当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用基本都是从同步队列里拿，不需要锁，是一个while（true  

### 可重入功能的实现原理

ReentrantLock的实现基于队列同步器（AbstractQueuedSynchronizer，后面简称AQS），关于AQS的实现原理，可以看笔者的另一篇文章：https://juejin.cn/post/6844903842530738184  
Java队列同步器（AQS）到底是怎么一回事  
ReentrantLock的可重入功能基于AQS的同步状态：state  
其原理大致为：当某一线程获取锁后，将state值+1，并记录下当前持有锁的线程，再有线程来获取锁时，判断这个线程与持有锁的线程是否是同一个线程，如果是，将state值再+1，如果不是，阻塞线程  
当线程释放锁时，将state值-1，当state值减为0时，表示当前线程彻底释放了锁，然后将记录当前持有锁的线程的那个字段设置为null，并唤醒其他线程，使其重新竞争锁  


### 为什么当线程池的核心线程满了后，是先加入到阻塞队列，而不是先创建新的线程？

线程池创建线程需要获取mainlock这个全局锁，会影响并发效率，所以使用阻塞队列把第一步创建核心线程与第三步创建最大线程隔离开来，起一个缓冲的作用  
引入阻塞队列，是为了在执行execute()方法时，尽可能的避免获取全局锁 

### 线程池的实现原理是什么
我们通过创建一个线程对象，并且实现Runnable接口就可以实现一个简单的线程。可以利用上多核  
CPU。当一个任务结束，当前线程就接收。 但很多时候，我们不止会执行一个任务。如果每次都是如此的创建线程->执行任务->销毁线程，会造成
很大的性能开销。 那能否一个线程创建后，执行完一个任务后，又去执行另一个任务，而不是销毁。这就是线程池。

这也就是池化技术的思想，通过预先创建好多个线程，放在池中，这样可以在需要使用线程的时候直接 获取，避免多次重复创建、销毁带来的开销。  
如果把线程池比作一个公司。公司会有正式员工处理正常业务，如果工作量大的话，会雇佣外包人员来 工作。  
闲时就可以释放外包人员以减少公司管理开销。一个公司因为成本关系，雇佣的人员始终是有最大数。 如果这时候还有任务处理不过来，就走需求池排任务。  
线程池创建参数如下:  
corePoolSize: 核心线程数量，可以类比正式员工数量，常驻线程数量。    
maximumPoolSize: 最大的线程数量，公司最多雇佣员工数量。常驻+临时线程数量。 workQueue:多余任务等待队列，再多的人都处理不过来了，需要等着，在这个地方等。 keepAliveTime:非核心线程空闲时间，就是外包人员等了多久，如果还没有活干，解雇了。 threadFactory: 创建线程的工厂，在这个地方可以统一处理创建的线程的属性。每个公司对员工 的要求不一样，恩，在这里设置员工的属性。 handler:线程池拒绝策略，什么意思呢?就是当任务实在是太多，人也不够，需求池也排满了， 还有任务咋办?默认是不处理，抛出异常告诉任务提交者，我这忙不过来了。  


### 使用线程池有哪些好处?

避免创建线程的开销。  
避免线程数量爆炸，导致系统崩溃  
合理控制线程数量，避免过度的资源竞争，造成系统性能急剧下降。   
利用特定线程池的功能特征，例如定时调度等  

### 线程池的 submit()和 execute() 方法有什么区别?
submit 方法: 有Future封装的返回值，执行中如果抛出异常，等待的方法中可以 catch 到。  
execute 方法: 无返回值，执行任务是捕捉不到异常的。  

### 线程池有哪些关闭方法?

shutdown() : 停止接收新任务，已有的任务继续执行  
shutdownNow() : 停止接收新任务，停止执行已有的任务，正在执行的线程会抛出 InterruptedException 异常  
awaitTermination(long timeOut, TimeUnit unit) : 当前线程阻塞，等待终止   

### 怎么提交任务?

提交一个任务到线程池中，线程池的处理流程如下:
1、判断线程池里的核心线程是否都在执行任务，如果不是(核心线程空闲或者还有核心线程没有被创 建)则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程  
2、线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。 如果工作队列满了，则进入下个流程  
3、判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果 已经满了，则交给饱和策略来处理这个任务  


### 怎么获取执行结果?

提交task到线程池后，可以获得Futrue对象，然后通过Future.get()获得执行结果。

### 如何控制线程池的线程池容量?

1、如果创建时知道需要多少线程，可以使用 newSingleThreadExecutor 或 newFixedThreadExecutor 创建单线程或固定大小线程  
2、如果不知道，可以使用 创建无限制的线程池。  
3、如果需要控制线程在一定范围内，可以直接使用ThreadPoolExecutor创建  

### 线程池怎样监控?

可以通过jstack，kill -3，jconsole/jvisualvm/jmc等工具监控。


### Java中同步加锁的关键字是什么?

synchronized


### synchronized 的原理是什么?

Java中的每个对象都是对象锁(Object monitor)，主要使用对象头标记字来实现。


### synchronized 方法使用的是哪个对象锁?

实例方法锁的是 this 代表的对象;   
静态方法锁的是对应的 Class 对象;   
synchronized块使用的是 this 对象。   
synchronized(obj)使用的是obj对象。  

### synchronized 有哪些优化?

synchronized方法优化  
偏向锁: BiaseLock, 轻量锁，其开销相当于没有锁  

### wait/notify 方法有什么作用?

object.wait() : 放弃锁  
object.notify() : 通知一个等待的线程来抢这个锁  
object.notifyAll() : 通知所有等待的线程来抢这个锁  


### synchronized 和 Lock 有什么区别?

synchronized方式的问题:  
1、同步块的阻塞无法中断(不能Interruptibly)   
2、同步块的阻塞无法控制超时(无法自动解锁)   
3、同步块无法异步处理锁(即不能立即知道是否可以拿到锁)   
4、同步块无法根据条件灵活的加锁解锁(即只能跟同步块范围一致)  
Lock 是更灵活的锁，使用方式灵活可控，支持更灵活的编程方式，性能开销小  
Lock接口设计:  
// 1.支持中断的API  
void lockInterruptibly() throws InterruptedException;  
// 2.支持超时的API  
boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
 
newCachedThreadExecutor
// 3.支持非阻塞获取锁的API boolean tryLock();  
// 4.可以根据条件灵活控制，newCondition设置多个通知信号  


### synchronized 和 Lock 相比，谁的性能高?

不一定，看具体场景。 synchronized退化成重量锁(Mutex)之后，高负载情况下性能开销会很大。


### 什么是可重入锁? 对象锁是不是可重入锁?

同一个线程，在执行到不同的方法时，可以多次获取这个锁  
synchronized 对应的锁属于可重入锁  
Java中的锁，一般都是重入锁，例如最基本的 ReentrantLock  

### 什么是公平锁? 对象锁是不是公平锁?

公平锁就是按申请的时间顺序，排队等待，依次分配  
synchronized 对应的锁是非公平锁,，这样做的目的是为了提高执行性能，缺点是可能会产生线程饥饿 现象  
ReentrantLock 提供了公平锁和非公平锁的实现。 无参构造函数默认创建的是非公平锁。 
公平锁: new ReentrantLock(true)  
非公平锁: new ReentrantLock(false)  

### 什么是乐观锁? 什么是悲观锁?

悲观锁和乐观锁是一种逻辑上的概念，最早出现在数据库中。 悲观锁适用于比较悲观的场景(并发争用很激烈)，采取直接加锁的方式。悲观地认为，不加锁的并发操  
作一定会出问题。例如 synchronized 锁，或者数据库的 select for update 等  
乐观锁并不真实存在锁的状态，适用于比较乐观，并发竞争情况不高的场景。 避免了悲观锁独占锁资源 的现象，同时也提高了乐观场景下的并发程序执行性能。 比如数据库操作使用版本号，Java的原子类 等  
在具体使用时, 乐观锁只在更新数据的时候，通过判断现有的数据是否和原数据一致来判断数据是否被 其他线程操作，如果没被其他线程修改则进行数据更新，如果被其他线程修改则不进行数据更新(+自旋 重试/while循环)  

### 什么是自旋锁?

自旋一般就是while循环，持续进行条件比较，比如Java的CAS操作  
缺点是如果情况很悲观，长时间获取锁不成功而一直自旋，会给 CPU 带来很大的开销  

### 什么是独占锁和共享锁?
独占锁是指任何时候都只有一个线程能获取的锁。 【信号量=1的场景】  
共享锁是指可以同时被多个线程共同持有的锁【信号量=N+的场景】  

### 什么是读写锁

Java 中的 ReentrantReadWriteLock, 允许一个线程进行写操作，允许多个线程读操作。 其中包括了两把锁:  
读锁, readerLock; 共享锁; 允许多个线程共同持有;  
写锁, writerLock; 独占锁, 互斥锁; 只能有1个线程获取; 同时排斥对应的读锁;  
注意:ReadWriteLock管理一组锁，一个读锁，一个写锁。 读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的。 所有读写锁的实现必须确保写操作对读操作的内存影响。每次只能有一个写线程，但是同时可以有多个 线程并发地读数据。ReadWriteLock适用于读多写少的并发情况  

### 使用锁有哪些注意事项

粒度、性能、重入、公平、自旋 根据具体场景来确定:  
保证业务需求, 所以需要使用的时候就使用。 适当降低锁的粒度, 提高性能。  
Doug Lea《Java 并发编程:设计原则与模式》一书中，推荐的三个用锁的最佳实践，分别是:
1. 永远只在更新对象的成员变量时加锁  
2. 永远只在访问可变的成员变量时加锁  
3. 永远不在调用其他对象的方法时加锁  
有那么锁使用的经验:  
减少synchronized的范围 同步代码块中尽量短，减少同步代码块中代码的执行时间，减少锁的竞争  
降低synchronized锁的粒度 将一个锁拆分为多个锁提高并发度(ashtable锁整个表、ConcurrentHashMap锁列) 读写分离  


### synchronized 锁升级是怎么回事?

锁的4中状态:无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态(级别从低到高)  
(1)偏向锁:  
为什么要引入偏向锁?  
因为经过HotSpot的作者大量的研究发现，大多数时候是不存在锁竞争的，常常是一个线程多次获得同 一个锁，因此如果每次都要竞争锁会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入的 偏向锁  
偏向锁的升级  
当线程1访问代码块并获取锁对象时，会在java对象头和栈帧中记录偏向的锁的threadID，因为偏向锁 不会主动释放锁，因此以后线程1再次获取锁的时候，需要比较当前线程的threadID和Java对象头中的 threadID是否一致，如果一致(还是线程1获取锁对象)，则无需使用CAS来加锁、解锁;如果不一致 (其他线程，如线程2要竞争锁对象，而偏向锁不会主动释放因此还是存储的线程1的threadID)，那么 需要查看Java对象头中记录的线程1是否存活，如果没有存活，那么锁对象被重置为无锁状态，其它线 程(线程2)可以竞争将其设置为偏向锁;如果存活，那么立刻查找该线程(线程1)的栈帧信息，如果 还是需要继续持有这个锁对象，那么暂停当前线程1，撤销偏向锁，升级为轻量级锁，如果线程1 不再 使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。
偏向锁的取消:
偏向锁是默认开启的，而且开始时间一般是比应用程序启动慢几秒，如果不想有这个延迟，那么可以使 用-XX:BiasedLockingStartUpDelay=0;
如果不想要偏向锁，那么可以通过-XX:-UseBiasedLocking = false来设置; (2)轻量级锁
为什么要引入轻量级锁?  
轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因为阻塞线程需要 CPU从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿 失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。
轻量级锁什么时候升级为重量级锁?  
线程1获取轻量级锁时会先把锁对象的对象头MarkWord复制一份到线程1的栈帧中创建的用于存储锁 记录的空间(称为DisplacedMarkWord)，然后使用CAS把对象头中的内容替换为线程1存储的锁记录 (DisplacedMarkWord)的地址;  
如果在线程1复制对象头的同时(在线程1CAS之前)，线程2也准备获取锁，复制了对象头到线程2的锁 记录空间中，但是在线程2CAS的时候，发现线程1已经把对象头换了，线程2的CAS失败，那么线程2就 尝试使用自旋锁来等待线程1释放锁  
但是如果自旋的时间太长也不行，因为自旋是要消耗CPU的，因此自旋的次数是有限制的，比如10次或 者100次，如果自旋次数到了线程1还没有释放锁，或者线程1还在执行，线程2还在自旋等待，这时又 有一个线程3过来竞争这个锁对象，那么这个时候轻量级锁就会膨胀为重量级锁。重量级锁把除了拥有 锁的线程都阻塞，防止CPU空转  
读取时不加锁，写入和删除时加锁  


### synchronized 和 volatile 的区别是什么?


volatile本质是在告诉jvm当前变量在寄存器(工作内存)中的值是不确定的，需要从主存中读 取;   
synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。  
volatile仅能使用在变量级别;  
synchronized则可以使用在变量、方法、和类级别的 volatile仅能实现变量的修改可见性，不能保证原子性;  
而synchronized则可以保证变量的修改可 见性和原子性  



volatile不会造成线程的阻塞;synchronized可能会造成线程的阻塞。 volatile标记的变量不会被编译器优化;synchronized标记的变量可以被编译器优化

### 什么是死锁?怎么防止死锁?


一、什么是死锁
死锁是指多个进程因竞争资源而造成的一种僵局(互相等待)，若无外力作用，这些进程都将无法向前 推进。例如，在某一个计算机系统中只有一台打印机和一台输入 设备，进程P1正占用输入设备，同时 又提出使用打印机的请求，但此时打印机正被进程P2 所占用，而P2在未释放打印机之前，又提出请求 使用正被P1占用着的输入设备。这样两个进程相互无休止地等待下去，均无法继续执行，此时两个进程 陷入死锁状态  
二、死锁产生的原因  
1. 系统资源的竞争  
系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁  

2. 进程运行推进顺序不合适  
进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。 

三、死锁的四个必要条件  
互斥条件:一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有 其他进程请求该资源，则请求进程只能等待。  
请求与保持条件:进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占 有，此时请求进程被阻塞，但对自己已获得的资源保持不放。  
不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源 的进程自己来释放(只能是主动释放)。  
循环等待条件: 若干进程间形成首尾相接循环等待资源的关系  

四、死锁的避免  
死锁避免的基本思想:系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结 果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则予以分配，这是一种保证系统 不进入死锁状态的动态策略。 如果操作系统能保证所有进程在有限时间内得到需要的全部资源，则系统处于安全状态否则系统是不安 全的。


### 对Java并发包有没有了解?

Java并发包指的是 java.util.concurrent(简称 JUC)包和其子包下的类和接口，为并发提供了各种功能支 持，比如:
锁机制类 Locks : Lock, Condition, ReadWriteLock  
原子操作类Atomic : AtomicInteger  
线程池相关类Executer : Future, Callable, Executor  
信号量三组工具类Tools : CountDownLatch, CyclicBarrier, Semaphore  
并发集合类Collections : CopyOnWriteArrayList, ConcurrentMap  

###  常用的原子操作类有哪些?



AtomicBoolean  
AtomicInteger  
AtomicLong  
LongAdder   
AtomicReference   
AtomicIntegerArray   
AtomicLongArray   
AtomicReferenceArray  

### 原子操作类的底层实现原理是什么?

无锁技术，内部调用 Unsafe API中的CAS(Compare and Swap)方法:
Unsafe API - Compare-And-Swap CPU硬件指令支持: CAS指令
两个要点: 
1、volatile的value变量保证可见性  
 。锁死生发会不就 ，足满不一之件条述上要只而，立成然必件条些这，锁死生发统系要只，件条要必的锁死是件条个四这
2、CAS操作保证写入不冲突  


### LongAdder 相比 AtomicLong有哪些改进,其实现原理是什么

采用了分段思想，支持更高的并发。

LongAdder extends Striped64;
transient volatile Cell[] cells;
public long sum() {
    Cell[] cs = cells;
    long sum = base;
    if (cs != null) {
        for (Cell c : cs)
            if (c != null)
}
return sum; }


### Semaphore 是什么? 与锁有什么区别?


Semaphore 即信号量, 是一个计数信号，即允许N个许可。  
acquire() 方法，阻塞方式获取一个许可。 release() 方法，释放一个许可  
如果信号量=1, 则等价于互斥锁。 如果信号量>1, 相当于共享锁  


### 用过 CountDownLatch 吗?


ountDownLatch(闭锁)可以看作一个只能做减法的计数器，可以让一个或多个线程等待执行  
场景: Master 线程等待 Worker 线程把任务执行完 示例:  
等所有人干完手上的活，包工头宣布下班休息  
吃酒席: 大家围成一桌, 等剩下的座位数归0, 服务员才上菜  
重要方法:  
特点:
1、采用减法计数，
2、各个子线程内countdown， 3、调用线程/主线程里await，作为聚合点，一直到计数为0


### Out of memory
内存溢出(OOM)是指可用内存不足。 程序运行需要使用的内存超出最大可用值，如果不进行处理就会影响到其他进程，所 以现在操作系统的处理办法是:只要超出立即报错，比如抛出 内存溢出错误 。

排查手段
一般手段是：先通过内存映像工具对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出。

如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。这样就能够找到泄漏的对象是通过怎么样的路径与GC Roots相关联的导致垃圾回收机制无法将其回收。掌握了泄漏对象的类信息和GC Roots引用链的信息，就可以比较准确地定位泄漏代码的位置。

如果不存在泄漏，那么就是内存中的对象确实必须存活着，那么此时就需要通过虚拟机的堆参数（ -Xmx和-Xms）来适当调大参数；从代码上检查是否存在某些对象存活时间过长、持有时间过长的情况，尝试减少运行时内存的消耗。


### Memory Leak

内存泄漏(Memory Leak)是指本来无用的对象却继续占用内存，没有再恰当的时机 释放占用的内存  
不使用的内存，却没有被释放，称为 内存泄漏 。 也就是该释放的没释放，该回收的 没回收  
比较典型的场景是: 每一个请求进来，或者每一次操作处理，都分配了内存，却有一部分不能回收(或未释放)，那么随着处理的请求越来越多，内存泄漏也就越来越严重  
在Java中一般是指无用的对象却因为错误的引用关系，不能被GC回收清理 

Exception in thread "main" java.lang.OutOfMemoryError: unable to create new native thread
这个意思是没有足够的内存空间给线程分配java栈，基本上还是线程池代码写的有问题，比如说忘记shutdown，所以说应该首先从代码层面来寻找问题，使用jstack或者jmap。如果一切都正常，JVM方面可以通过指定Xss来减少单个thread stack的大小。另外也可以在系统层面，可以通过修改/etc/security/limits.confnofile和nproc来增大os对线程的限制

Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
这个意思是堆的内存占用已经达到-Xmx设置的最大值，应该是最常见的OOM错误了。解决思路仍然是先应该在代码中找，怀疑存在内存泄漏，通过jstack和jmap去定位问题。如果说一切都正常，才需要通过调整Xmx的值来扩大内存

Caused by: java.lang.OutOfMemoryError: Meta space
这个意思是元数据区的内存占用已经达到XX:MaxMetaspaceSize设置的最大值，排查思路和上面的一致，参数方面可以通过XX:MaxPermSize来进行调整(这里就不说1.8以前的永久代了)

### Stack Overflow

栈内存溢出，这个大家见到也比较多。

Exception in thread "main" java.lang.StackOverflowError
表示线程栈需要的内存大于Xss值，同样也是先进行排查，参数方面通过Xss来调整，但调整的太大可能又会引起OOM。

### 设置堆内存XMX应该考虑哪些因素?

需要根据系统的配置来确定，要给操作系统和JVM本身留下一定的剩余空间  
推荐配置系统或容器里可用内存的 70­80% 最好  

### 怎样开启GC日志

一般来说，JDK8及以下版本通过以下参数来开启GC日志:  
‐XX:+PrintGCDetails ‐XX:+PrintGCDateStamps ‐Xloggc:gc.log
如果是在JDK9及以上的版本，则格式略有不同:  
   ‐Xlog:gc*=info:file=gc.log:time:filecount=0

### Java8默认使用的垃圾收集器是什么?

Java8版本的Hotspot JVM，默认情况下使用的是并行垃圾收集器(Parallel GC) 其
他厂商提供的JDK8基本上也默认使用并行垃圾收集器  

### Java11的默认垃圾收集器是什么?
Java9之后，官方JDK默认使用的垃圾收集器是G1  

### 常见的垃圾收集器有哪些
常见的垃圾收集器包括:
串行垃圾收集器: ‐XX:+UseSerialGC  
并行垃圾收集器: ‐XX:+UseParallelGC  
CMS垃圾收集器: ‐XX:+UseConcMarkSweepGC  
G1垃圾收集器: ‐XX:+UseG1GC  

### 什么是串行垃圾收集
就是只有单个worker线程来执行GC工作。


### 什么是并行垃圾收集

并行垃圾收集，是指使用多个GC worker 线程并行地执行垃圾收集，能充分利用多核 CPU的能力，缩短垃圾收集的暂停时间。 除了单线程的GC，其他的垃圾收集器，比如 PS，CMS， G1等新的垃圾收集器都使  
用了多个线程来并行执行GC工作。  
### 什么是并发垃圾收集器

并发垃圾收集器，是指在应用程序在正常执行时，有一部分GC任务，由GC线程在应 用线程一起并发执行  
例如 CMS/G1的各种并发阶段  

### 什么是增量式垃圾收集

首先， G1的堆内存不再单纯划分为年轻代和老年代，而是划分为多个(通常是 2048 个)可以存放对象的小块堆区域(smaller heap regions)。 每个小块，可能一会被定义成 Eden 区，一会被指定为 Survivor 区或者 Old 区。 这样划分之后，使得 G1 不必每次都去回收整个堆空间，而是以增量的方式来进行处 理: 每次只处理一部分内存块，称为此次 GC 的回收集(collection set)。 下一次GC时在本次的基础上，再选定一定的区域来进行回收。增量式垃圾收集的好处 是大大降低了单次GC暂停的时间。  


### 如果CPU使用率突然飙升，你会怎么排查

缺乏经验的话，针对当前问题，往往需要使用不同的工具来收集信息，例如:
收集不同的指标(CPU，内存，磁盘IO，网络等等) 分析应用日志  
分析GC日志  
获取线程转储并分析  
获取堆转储来进行分析  

### 如果系统响应变慢，你会怎么排

一般根据APM监控来排查应用系统本身的问题  
有时候也可以使用Chrome浏览器等工具来排查外部原因，比如网络问题  

### 系统性能一般怎么衡量

可量化的3个性能指标:  
系统容量:比如硬件配置，设计容量; 吞吐量:最直观的指标是TPS; 响应时间:也就是系统延迟，包括服务端延时和网络延迟  
这些指标。可以具体拓展到单机并发，总体并发，数据量，用户数，预算成本等等  

### 怎么查看剩余内存

比如: free ‐m , free ‐h , top 命令等等。

### 查看线程栈的工具是什么

一般先使用 jps命令， 再使用 jstack ‐l


### 内存Dump时有哪些注意事项?

根据实际情况来看，获取内存快照可能会让系统暂停或阻塞一段时间，根据内存量决 定  
使用jmap时，如果指定 live 参数，则会触发一次FullGC，需要注意  

### 使用JMAP转储堆内存大致的参数怎么处理

jmap ‐dump:format=b,file=3826.hprof 3826

### 为什么转储文件以 .hprof 结尾
JVM有一个内置的分析器叫做HPROF, 堆内存转储文件的格式，最早就是这款工具定
义的。

### 内存Dump完成之后，用什么工具来分析

一般使用 Eclipse MAT工具，或者 jhat 工具来处理。


